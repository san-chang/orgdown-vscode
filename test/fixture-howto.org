#+TITLE: Test Fixture Format Guide

* 1. Introduction

This directory contains the test fixtures for Orgdown's tests. These files serve as the **Single Source of Truth (SSoT)** for defining the expected behavior of our:
- Regular expressions (TextMate grammar)
- Scope mappings (TextMate grammar)
- Structural features (tree-sitter)

The test runners automatically discover and execute these `.org` files:
- `test/unit/grammar-regex.test.ts` - Regex tests
- `test/unit/grammar-scoping.test.ts` - Scope tests
- `test/unit/folding-fixture.test.ts` - Folding range tests
- `test/unit/symbols-fixture.test.ts` - Document symbol tests

* 2. Fixture Structure

Each fixture file is composed of one or more test cases. Each test case MUST follow this structure:

#+BEGIN_SRC org
#+NAME: A clear and descriptive name for the test case
#+BEGIN_FIXTURE
The Org Mode text to be tested against a regex.
#+END_FIXTURE

#+EXPECTED: :type regex :name <regexName>
... regex expected results ...
#+END_SRC

* 3. Core Components

*** 3.1. Test Case Name (`#+NAME`)

- **Purpose**: Uniquely identifies the test case. The name will be used in the test runner's output.
- **Format**: `#+NAME: <Your Descriptive Name>`

*** 3.2. Test Input (`#+BEGIN_FIXTURE`)

- **Purpose**: Contains the raw text input for the test. The input can span multiple lines.
- **Format**: The text must be enclosed in a `#+BEGIN_FIXTURE` / `#+END_FIXTURE` block. This custom block is used to avoid conflicts with standard Org Mode syntax.

  #+BEGIN_FIXTURE
  This is the first line of input.
  This is the second line, which is also part of the input.
  #+END_FIXTURE

*** 3.3. Expected Results (`#+EXPECTED`)

- **Purpose**: Defines the assertion(s) to be made for the test case.
- **Formats**:
  - Regex assertions: `#+EXPECTED: :type regex :name <regexName>` where `<regexName>` MUST be the exact name of a regex constant exported from `common/src/grammar/regex.ts`.
  - Scope assertions: `#+EXPECTED: :type scope` followed by one or more arrow lines in the format `text => scope[, scope2, ...]` (see Section 5).

* 4. Assertion Types

There are two types of assertions you can make.

*** 4.1. Asserting a Match (Regex)

To assert that the input *should* match the regex, provide a table of expected capture group values.

- The table MUST have two columns: `Group #` and `Expected Value`.

- **Important**: There is a critical difference between omitting a group from the table and explicitly setting its value to `undefined`.
  - **Omitting a group**: If a group number is not present in the table, the test runner **will not check it**. This means you don't care about its result.
  - **Value as `undefined`**: If a group's expected value is the literal string `undefined`, the test runner will **assert that the group was not captured** (i.e., its result is `undefined`). This is essential for testing optional capture groups.
  - **Value as empty**: To assert that a group captured an empty string, leave the `Expected Value` cell blank (e.g., `| 1 | |`).

#+BEGIN_SRC org
#+NAME: Example of a matching test
#+BEGIN_FIXTURE
* TODO [#A] A task
#+END_FIXTURE
#+EXPECTED: :type regex :name headlineLevel1Regex
| Group # | Expected Value |
|---------+----------------|
| 1       | *              |
| 2       | TODO           |
| 3       | [#A]           |
| 4       | A              |
| 5       | A task         |
| 7       | undefined      |
# In this example, we assert that group 7 (tags) MUST be undefined.
# We don't care about group 6 (progress), so it's omitted from the table.
#+END_SRC

*** 4.2. Asserting No Match (Regex)

To assert that the input *should not* match the regex, use the keyword `no-match`.

#+BEGIN_SRC org
#+NAME: Example of a non-matching test
#+BEGIN_FIXTURE
This is not a headline.
#+END_FIXTURE
#+EXPECTED: :type regex :name headlineLevel1Regex
no-match
#+END_SRC

*** 4.3. Test style guidance: prefer regex for single-line, scope for multi-line

To keep fixtures precise and easy to maintain, prefer the following guideline when choosing assertion types:

- Single-line constructs (like an isolated headline, inline link, or a single footnote definition line) should primarily use `:type regex` assertions. Regex tests are ideal for verifying capture groups and exact textual structure.
- Begin/end constructs that represent multi-line regions (for example a block, a multi-line footnote definition, a src block, or an example block) should primarily use `:type scope` assertions. Scope assertions express the expected tokenization and are better suited to validating multi-line highlighting and nesting.

Rationale: Regex assertions give tight control over capture groups and are fast to author for single-line expectations. Scope assertions are more robust for region-based highlighting and for tests that must verify token scopes across line boundaries.

You may combine both styles in a single fixture when useful (see Section 7 "One-to-Many Testing"). Prefer the style that makes the test easiest to understand and least brittle.


* 5. Scope Assertions for Theming & Scoping

To make fixtures a complete reference for theme developers, scope expectations are specified with an arrow-based, multi-line, human-friendly format.

- Use `#+EXPECTED: :type scope` followed by one or more lines in the form:
  `text => scope[, scope2, ...]`

- Left side `text` identifies a contiguous region on a single line. You can quote it with single or double quotes to include spaces or special characters.
- Right side is one or more scope names, comma-separated. Prefix with `!` to mark a forbidden scope.
- Matching semantics (unit test harness):
  - Candidate selection: when `text` appears multiple times,
    - If assertions are indented (tree model), resolve parent first and restrict children to the parent’s region;
    - Otherwise, pick the earliest occurrence by (line, column).
  - Scope aggregation per region: the region may overlap multiple tokens. We compute:
    - UNION: the set of all scopes present on any overlapping token,
    - INTERSECTION: the set of scopes common to all overlapping tokens.
  - Assertions:
    - Positive scopes (right-hand side without `!`) are checked against the UNION. All listed scopes MUST be present in the UNION.
    - Forbidden scopes (prefixed with `!`) are checked against the INTERSECTION. None of the listed scopes may appear in the INTERSECTION.
  - Rationale: This allows region-level assertions such as `"*bold*" => !markup.bold.org, meta.inline.bold.org` where the region is recognized as a bold container (`meta.inline.bold.org`) but its content scope (`markup.bold.org`) is not considered part of every overlapping token (thus forbidden in the intersection), even though some sub-token carries it.
- Readability helpers (optional):
  - You may indent lines or prefix with `- ` for visual grouping; they will be ignored by the parser.
  - Special placeholders in `text` are supported and will be converted before matching:
    - `<sp:N>` → N spaces
    - `<tab>` → a tab character
    - `<pipe>` → a literal `|`

- Recommended placement:
  - Put a self-explanatory “Show Case” test case near the top of the file, containing both a representative fixture and its scope assertions.
  - Then follow with additional cases (regex or scope) as needed.

**Example (from `F01-headlines.org`)**:
#+BEGIN_SRC org
#+TITLE: Test Suite for Headlines

#+NAME: Complete headline with all elements
#+BEGIN_FIXTURE
,* TODO [#A] Complete headline example [2/5] :work:project:
#+END_FIXTURE
#+EXPECTED: :type regex :name headlineLevel1Regex
| Group # | Expected Value            |
|---------+---------------------------|
| 1       | *                         |
| 2       | TODO                      |
| 3       | [#A]                      |
| 4       | A                         |
| 5       | Complete headline example |
| 6       | [2/5]                     |
| 7       | :work:project:            |
#+EXPECTED: :type scope
"*" => markup.heading.org, markup.heading.1.org, punctuation.definition.heading.org
"<sp:1>" => markup.heading.org, markup.heading.1.org
"TODO" => markup.heading.org, markup.heading.1.org, keyword.other.todo.org
... etc.
#+END_SRC

**Example (region-based, inline markup)**
#+BEGIN_SRC org
#+NAME: Bold: Showcase
#+BEGIN_FIXTURE
This is *bold* text.
#+END_FIXTURE
#+EXPECTED: :type scope
"*" => punctuation.definition.bold.org
"bold" => markup.bold.org
"*" => punctuation.definition.bold.org
#+EXPECTED: :type scope
"*bold*" => !markup.bold.org, meta.inline.bold.org
#+END_SRC

*** 5.1 Indentation-based nesting (tree model)

- You can express parent–child relationships using indentation before each assertion line. Tabs are normalized to 4 spaces before measuring. An optional leading bullet "- " is for readability and is ignored when computing depth.
- Execution semantics:
  - The harness first resolves a parent node to a specific region (line + [start, end)).
  - Child nodes are evaluated with candidates restricted to the same line and within the parent’s [start, end) span.
  - Scope checks remain: mustContain via UNION; mustNotContain via INTERSECTION.
- Backward compatibility: Without indentation, assertions are independent; indentation only narrows candidate search.

Example (table cell with nested inline markup):

#+BEGIN_SRC org
#+NAME: Table - inline markup edgecases
#+BEGIN_FIXTURE
| Header | H2 |
|-------+----|
| *a* /b/ =c= | mixed |
#+END_FIXTURE

#+EXPECTED: :type scope
"| *a* /b/ =c= | mixed |" => meta.table.row.org, meta.table.content.org
- "*a* /b/ =c=" => meta.table.cell.org
  - "*a*" => meta.inline.bold.org
    - "a" => markup.bold.org
  - "/b/" => meta.inline.italic.org
    - "b" => markup.italic.org
  - "=c=" => meta.inline.verbatim.org
    - "c" => markup.verbatim.org
#+END_SRC

* 6. Special Syntaxes in Results

To handle whitespace and other special characters cleanly in the results table, we use a special syntax. The test runner will parse these strings and convert them to their literal values before making an assertion.

- `<sp:N>`: Represents N space characters.
  - Example: `<sp:1>` becomes `" "`.
  - Example: `<sp:4>` becomes `"    "`.
- `<tab>`: Represents a literal tab character (`\t`).
- `<pipe>`: Represents a literal vertical bar (`|`).

*Example*:

#+BEGIN_SRC org
#+NAME: Space-indented list with checkbox
#+BEGIN_FIXTURE
  - [ ] A task
#+END_FIXTURE
#+EXPECTED: unorderedListRegex
| Group # | Expected Value |
|---------+----------------|
| 1       | <sp:2>         |
| 3       | <sp:1>         |
#+END_SRC

* 7. Advanced: One-to-Many Testing

The test runner supports testing a single input against multiple regular expressions. To do this, simply place multiple `#+EXPECTED` blocks one after another.

#+BEGIN_SRC org
#+NAME: Testing one input against two regexes
#+BEGIN_FIXTURE
,* A headline
#+END_FIXTURE

#+EXPECTED: :type regex :name headlineLevel1Regex
| Group # | Expected Value |
|---------+----------------|
| 1       | *              |
| 5       | A headline     |

#+EXPECTED: :type regex :name headlineDetectRegex
| Group # | Expected Value |
|---------+----------------|
| 1       | * A headline   |
#+END_SRC

* 8. Structural Testing (Tree-sitter)

In addition to TextMate grammar tests (regex and scope), we also test structural features powered by tree-sitter, such as code folding and document symbols.

** 8.1. Testing Philosophy

Structural tests verify that the tree-sitter parser correctly identifies document structure and that our feature logic correctly extracts information from the AST.

- *Separation of Concerns*: Structural tests are independent of TextMate grammar tests. They test different layers of the architecture (see [[file:../docs/architecture_decisions/008-tree-sitter-integration.org][ADR-008]]).
- *SSoT Principle*: Fixtures remain the single source of truth. Structural tests parse the same `.org` files as grammar tests.
- *Test Location*: Structural tests are in `test/unit/folding-fixture.test.ts` and `test/unit/symbols-fixture.test.ts`.

** 8.2. Folding Range Tests

Folding tests verify that foldable regions (headlines, blocks, drawers) are correctly identified.

*** Test Format

Folding tests use `#+EXPECTED: :type folding` followed by a list of fold ranges in `[startLine-endLine]` format:

#+BEGIN_SRC org
#+NAME: Headline folding
#+BEGIN_FIXTURE
,* Level 1
Content here.
,** Level 2
More content.
#+END_FIXTURE
#+EXPECTED: :type folding
[0-3]
#+END_SRC

- Each range is written as `[startLine-endLine]` (0-based line numbers, end-inclusive).
- In the example above, we expect one fold from line 0 to line 3 (the entire "Level 1" section).

*** Multiple Fold Regions

For documents with multiple foldable regions, list all ranges separated by commas:

#+BEGIN_SRC org
#+NAME: Multiple blocks
#+BEGIN_FIXTURE
,#+BEGIN_SRC python
print("hello")
,#+END_SRC

,#+BEGIN_EXAMPLE
Example text
,#+END_EXAMPLE
#+END_FIXTURE
#+EXPECTED: :type folding
[0-2], [4-6]
#+END_SRC

*** Nested Folds

Tree-sitter naturally handles nested structures. Both the parent and child folds should be listed:

#+BEGIN_SRC org
#+NAME: Nested structure
#+BEGIN_FIXTURE
,* Headline
,#+BEGIN_SRC python
code
,#+END_SRC
#+END_FIXTURE
#+EXPECTED: :type folding
[0-3], [1-3]
#+END_SRC

Here, line 0-3 is the headline section, and line 1-3 is the source block.

** 8.3. Document Symbol Tests

Symbol tests verify that the document outline (headline hierarchy) is correctly extracted.

*** Test Format

Symbol tests use `#+EXPECTED: :type symbols` followed by an indented tree structure showing symbol names and ranges:

#+BEGIN_SRC org
#+NAME: Simple outline
#+BEGIN_FIXTURE
,* Project Alpha
Content.
,** Task 1
Task content.
#+END_FIXTURE
#+EXPECTED: :type symbols
- Project Alpha (0:0-3:0)
  - Task 1 (2:0-3:0)
#+END_SRC

- Each line has the format: `- Name (startLine:startChar-endLine:endChar)`
- Indentation (2 spaces per level) indicates the hierarchy
- Line and character positions are 0-based
- In the example above:
  - "Project Alpha" starts at line 0, character 0 and ends at line 3, character 0
  - "Task 1" is a child of "Project Alpha", at line 2

*** Flat Structure

For documents with no nesting:

#+BEGIN_SRC org
#+NAME: Flat outline
#+BEGIN_FIXTURE
,* Task 1
,* Task 2
,* Task 3
#+END_FIXTURE
#+EXPECTED: :type symbols
- Task 1 (0:0-1:0)
- Task 2 (1:0-2:0)
- Task 3 (2:0-3:0)
#+END_SRC

*** Deep Nesting

For deeply nested hierarchies, use consistent indentation to show the tree:

#+BEGIN_SRC org
#+NAME: Deep nesting
#+BEGIN_FIXTURE
,* L1
,** L2
,*** L3
#+END_FIXTURE
#+EXPECTED: :type symbols
- L1 (0:0-2:8)
  - L2 (1:0-2:8)
    - L3 (2:0-2:8)
#+END_SRC

** 8.4. Implementation Notes

- Structural tests use `#+EXPECTED: :type folding` or `#+EXPECTED: :type symbols` blocks (similar to regex and scope tests).
- The test harness uses `common/src/fixture-parser.ts` to parse fixtures and `common/src/folding.ts` or `server/src/features/symbols.ts` for the actual logic.
- If a test case lacks a folding or symbols expectation, it is skipped by the respective test runner.

** 8.5. Best Practices

- *Keep It Simple*: Start with simple cases (single headline, single block) before testing complex nesting.
- *Explicit Expectations*: Always specify expected folds/symbols explicitly, even if empty (`[]`).
- *Reuse Fixtures*: You can add structural expectations to existing fixtures used for grammar tests. Just add the properties to the test case.
- *Document Edge Cases*: Use descriptive test names (e.g., "Empty headline with no content", "Malformed block missing END").

* 9. Summary

This fixture format provides a unified, self-documenting way to test all aspects of Orgdown:
- **Regex tests** verify that our patterns capture the correct data.
- **Scope tests** verify that tokens receive the correct TextMate scopes for theming.
- **Folding tests** verify that foldable regions are correctly identified.
- **Symbol tests** verify that the document outline is correctly extracted.

All tests share the same source files, ensuring consistency and reducing maintenance burden. For more details on the testing architecture, see [[../docs/architecture_decisions/005-unified-grammar-and-test-workflow.org][ADR-005]] and [[../docs/architecture_decisions/008-tree-sitter-integration.org][ADR-008]].
